syntax="proto3";

package clone.hardware_driver;

import "google/protobuf/empty.proto";

import "clone_client/proto/data_types.proto";


service HardwareDriverGRPC {
  rpc SendDirect (SendDirectMessage) returns (clone.data_types.ServerResponse);
  rpc SendManyDirect (SendManyDirectMessage) returns (clone.data_types.ServerResponse);
  rpc SendImpulse (SendImpulseMessage) returns (clone.data_types.ServerResponse);
  rpc SendManyImpulse (SendManyImpulseMessage) returns (clone.data_types.ServerResponse);

  rpc SendPinchValveControl (SendPinchValveControlMessage) returns (clone.data_types.ServerResponse);
  rpc SendManyPinchValveControl (SendManyPinchValveControlMessage) returns (clone.data_types.ServerResponse);
  rpc StreamManyPinchValveControl (stream SendManyPinchValveControlMessage) returns (clone.data_types.ServerResponse);
  rpc SendPinchValveCommand (SendPinchValveCommandMessage) returns (clone.data_types.ServerResponse);
  rpc SendManyPinchValveCommand (SendManyPinchValveCommandMessage) returns (clone.data_types.ServerResponse);

  rpc SendManyPressure (SendManyPressureMessage) returns (clone.data_types.ServerResponse);
  rpc StreamManyPressure (stream SendManyPressureMessage) returns (clone.data_types.ServerResponse);

  // Get list of nodes discovered at startup (as opposed to `Discovery`)
  rpc GetNodes (google.protobuf.Empty) returns (NodeMap);
  rpc PingNode (PingNodeMessage) returns (clone.data_types.ServerResponse);
  // Conduct discovery and return discovered nodes
  rpc Discovery (DiscoveryMessage) returns (DiscoveryResponse);
  rpc GetNodesSettings (GetNodesSettingsMessage) returns (GetNodesSettingsResponse);

  rpc GetGaussRiderSpecSettings(google.protobuf.Empty) returns (GaussRiderSpecSettingsResponse);

  rpc GetErrors(google.protobuf.Empty) returns (HwDriverErrors);
}

message GaussRiderSpecSettings {
  uint32 should_write = 2;
  repeated uint32 register_address = 3;
  repeated int32 measurement_cfg_x = 4;
  repeated int32 measurement_cfg_y = 5;
  repeated int32 measurement_cfg_z = 6;
  int32 measurement_cfg_temperature = 7;
  repeated int32 offsets_0 = 8;
  repeated int32 Hval_P_T0 = 9;
  repeated int32 Hval_N_T0 = 10;
  repeated int32 temperatures = 11;
  repeated int32 Hval_P_T1 = 12;
  repeated int32 Hval_N_T1 = 13;
  repeated int32 offsets_1 = 14;
  repeated int32 Hval_O_P = 15;
  repeated int32 Hval_O_N = 16;
}

message GaussRiderSpecSettingsResponse {
  message SuccessMessage {
      map<uint32, GaussRiderSpecSettings> spec_settings = 1;
  }
  oneof inner {
    SuccessMessage success = 1;
    clone.data_types.ErrorInfo error = 2;
  }
}

message SendDirectMessage {
  uint32 node_id = 1;
  uint32 valves = 2;
}

message SendManyDirectMessage {
  map<uint32, uint32> data = 1;
}

message ImpulseControl {
  uint32 valves = 1;
  uint32 delay = 2;
}

message SendImpulseMessage {
  uint32 node_id = 1;
  ImpulseControl control = 2;
}

message SendManyImpulseMessage {
  map<uint32, ImpulseControl> data = 1;
}

message SendPulseMessage {
  uint32 node_id = 1;
  uint32 valve_id = 2;
  uint32 pulse_len_ms = 3;
  uint32 delay_len_ms = 4;
  uint32 duration_ms = 5;
}

message PressureControl {
  repeated int32 pressures = 1;
}

message SendManyPressureMessage {
  map<uint32, PressureControl> data = 1;
}

message PinchValveControl {
  enum PositionsType {
      POSITION_UNKNOWN = 0;	// Cam position unknown
      BOTH_CLOSED = 1;	// Both inlet and outlet are closed
      BOTH_OPENED = 2;	// Both inlet and outlet are opened, AKA flush
      INLET_FULLY_OPENED = 3;	// Inlet valve fully opened
      INLET_PARTIALLY_OPENED = 4;	// Inlet valve opened, but only partially
      OUTLET_FULLY_OPENED = 5;	// Outlet valve fully opened
      OUTLET_PARTIALLY_OPENED = 6;	// Outlet valve opened, but only partially
  }

  enum ControlMode {
      RESERVED = 0;
      ANGLE = 1;
      PRESSURE = 2;
      POSITIONS = 3;
  }

  ControlMode mode = 1;
  int32 value = 2;
}

message SendPinchValveControlMessage {
  uint32 node_id = 1;
  PinchValveControl control = 2;
}

message SendManyPinchValveControlMessage {
  map<uint32, PinchValveControl> data = 1;
}

message HydraControlMessage {
  enum PositionsType {
      POSITION_UNKNOWN = 0;	// Cam position unknown
      BOTH_CLOSED = 1;	// Both inlet and outlet are closed
      BOTH_OPENED = 2;	// Both inlet and outlet are opened, AKA flush
      INLET_FULLY_OPENED = 3;	// Inlet valve fully opened
      INLET_PARTIALLY_OPENED = 4;	// Inlet valve opened, but only partially
      OUTLET_FULLY_OPENED = 5;	// Outlet valve fully opened
      OUTLET_PARTIALLY_OPENED = 6;	// Outlet valve opened, but only partially
  }
  message Angles {
    repeated float angles = 1;
  }
  message Pressures {
    repeated int32 pressures = 1;
  }
  message Positions {
    repeated PositionsType positions = 1;
  }
  message Speeds {
    repeated int32 speeds = 1;
  }

  oneof value {
    Angles angles = 1;
    Pressures pressures = 2;
    Positions positions = 3;
    Speeds speeds = 4;
  }
}

message SendHydraControlMessage {
  uint32 node_id = 1;
  HydraControlMessage control = 2;
}

message SendManyHydraControlMessage {
  map<uint32, HydraControlMessage> data = 1;
}

message GetNodesMessage {
  // bool rediscover = 1;
  optional uint32 product_id = 2;
}

message BusDevice {
  uint32 node_id = 1;
  uint32 product_id = 2;
}

message NodeList {
  repeated BusDevice nodes = 1;
}

message NodeMap {
  map<string, NodeList> nodes = 1;
}

enum PinchValveCommands {
    RESERVED = 0;
    ENABLE_STEPPER_DRIVER = 1;
    DISABLE_STEPPER_DRIVER = 2;
    ENABLE_STEPPER_VBOOST = 3;
    DISABLE_STEPPER_VBOOST = 4;
}

message SendPinchValveCommandMessage {
    uint32 node_id = 1;
    PinchValveCommands command = 2;
}

message SendManyPinchValveCommandMessage {
    map<uint32, PinchValveCommands> commands = 1;
}

message PingNodeMessage {
  uint32 node_id = 1;
  string bus_name = 2;
  uint64 timeout_us = 3;
}

message DiscoveryMessage {
  message DiscoveryRange {
    uint32 start_node = 1;
    uint32 end_node = 2;
  }
  string bus_name = 1;
  uint64 timeout_us = 2;
  // for mass discovery enter 0 - 254 range, optionally
  // eliminating some nodes with a blacklist
  repeated DiscoveryRange discovery_ranges = 3;
  repeated uint32 discovery_blacklist = 4;
}

message DiscoveryResponse {
  clone.data_types.ServerResponse server_response = 1;
  repeated uint32 node_ids = 2;
}

message GetNodesSettingsMessage {
  string bus_name = 1;
  repeated uint32 node_ids = 2;
  uint64 timeout_us = 3;
}

message NodeGenericSettings {
  uint32 node_id = 1;
  int32 product_id = 2;
  int32 pcb_id = 3;
  int32 _valve_hold_duty = 4; // legacy
  int32 _pad3 = 5;
  int32 device_random_id = 6;
}

message GetNodesSettingsResponse {
  // if None then no response was received
  message NodeSettingsWrapper {
    optional NodeGenericSettings settings = 1;
  }
  // if whole map is empty than no such a bus exists
  map<uint32, NodeSettingsWrapper> settings = 1;
}

message HwDriverErrors {
  // inner error list, cause this field is implicitly optional
  clone.data_types.ErrorList.ErrorList hw_driver_errors = 1;
  map<string, clone.data_types.ErrorList> buses_errors = 2;
}
